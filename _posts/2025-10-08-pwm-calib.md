---
layout: post
title:  "esp8266æ™ºèƒ½è½¦æµ‹é€Ÿ"
author: "David"
header-style: text
tags: 
    - stemæ•™è‚²
    - Maker
    - æ™ºèƒ½è½¦
---

# ESP8266ç¡®å®šç”µæœºæœ€å°å¯åŠ¨PWMçš„å®Œæ•´æŒ‡å—

ç¡®å®šç”µæœºçš„æœ€å°å¯åŠ¨PWMå€¼æ˜¯å®ç°ç²¾ç¡®ä½é€Ÿæ§åˆ¶çš„å…³é”®ã€‚ä»¥ä¸‹æ˜¯å¤šç§æ–¹æ³•çš„è¯¦ç»†å®ç°ã€‚

## ğŸ”§ åŸºç¡€æ‰‹åŠ¨æ ¡å‡†æ–¹æ³•

### 1. ä¸²å£äº¤äº’å¼æ ¡å‡†
```cpp
#include <Arduino.h>

#define MOTOR_PWM_PIN D1
#define MOTOR_DIR_PIN D2

void setup() {
  Serial.begin(115200);
  pinMode(MOTOR_PWM_PIN, OUTPUT);
  pinMode(MOTOR_DIR_PIN, OUTPUT);
  
  analogWriteRange(1023);
  analogWriteFreq(1000);
  
  Serial.println("=== ç”µæœºæœ€å°å¯åŠ¨PWMæ ¡å‡†ç¨‹åº ===");
  Serial.println("æŒ‡ä»¤:");
  Serial.println("s - å¼€å§‹æ ¡å‡†");
  Serial.println("+ - å¢åŠ PWMå€¼");
  Serial.println("- - å‡å°‘PWMå€¼");
  Serial.println("y - ç¡®è®¤å½“å‰PWMä¸ºæœ€å°å¯åŠ¨å€¼");
  Serial.println("0 - åœæ­¢ç”µæœº");
}

int currentPwm = 0;
bool calibrating = false;

void loop() {
  if (Serial.available()) {
    char command = Serial.read();
    
    switch (command) {
      case 's': // å¼€å§‹æ ¡å‡†
        calibrating = true;
        currentPwm = 0;
        analogWrite(MOTOR_PWM_PIN, currentPwm);
        digitalWrite(MOTOR_DIR_PIN, HIGH);
        Serial.println("å¼€å§‹æ ¡å‡† - ä»PWM=0å¼€å§‹");
        break;
        
      case '+': // å¢åŠ PWM
        if (calibrating) {
          currentPwm += 5;
          currentPwm = constrain(currentPwm, 0, 1023);
          analogWrite(MOTOR_PWM_PIN, currentPwm);
          Serial.printf("PWMå¢åŠ åˆ°: %d\n", currentPwm);
        }
        break;
        
      case '-': // å‡å°‘PWM
        if (calibrating) {
          currentPwm -= 5;
          currentPwm = constrain(currentPwm, 0, 1023);
          analogWrite(MOTOR_PWM_PIN, currentPwm);
          Serial.printf("PWMå‡å°‘åˆ°: %d\n", currentPwm);
        }
        break;
        
      case 'y': // ç¡®è®¤æ‰¾åˆ°æœ€å°å€¼
        if (calibrating) {
          calibrating = false;
          analogWrite(MOTOR_PWM_PIN, 0);
          Serial.printf("âœ… æœ€å°å¯åŠ¨PWMç¡®å®šä¸º: %d\n", currentPwm);
          Serial.println("è¯·è®°å½•æ­¤å€¼ç”¨äºç”µæœºæ§åˆ¶");
        }
        break;
        
      case '0': // åœæ­¢ç”µæœº
        calibrating = false;
        analogWrite(MOTOR_PWM_PIN, 0);
        Serial.println("ç”µæœºå·²åœæ­¢");
        break;
    }
  }
}
```

### 2. è‡ªåŠ¨æ­¥è¿›æ‰«ææ³•
```cpp
/**
 * è‡ªåŠ¨æ‰«æå¯»æ‰¾æœ€å°å¯åŠ¨PWM
 * ä»¥å›ºå®šæ­¥é•¿å¢åŠ PWMï¼Œåœ¨æ¯ä¸ªå€¼åœç•™ä¸€æ®µæ—¶é—´
 */
void autoScanMinPwm() {
  Serial.println("å¼€å§‹è‡ªåŠ¨æ‰«ææœ€å°å¯åŠ¨PWM...");
  Serial.println("è§‚å¯Ÿç”µæœºå¹¶åœ¨å¼€å§‹è½¬åŠ¨æ—¶è®°å½•PWMå€¼");
  
  int startPwm = 0;
  int endPwm = 200;
  int step = 5;
  int dwellTime = 3000; // æ¯ä¸ªPWMå€¼çš„åœç•™æ—¶é—´(ms)
  
  for (int pwm = startPwm; pwm <= endPwm; pwm += step) {
    analogWrite(MOTOR_PWM_PIN, pwm);
    digitalWrite(MOTOR_DIR_PIN, HIGH);
    
    Serial.printf("æµ‹è¯• PWM: %3d - ", pwm);
    Serial.println("è§‚å¯Ÿç”µæœºæ˜¯å¦å¼€å§‹æŒç»­è½¬åŠ¨");
    
    // åœ¨æ¯ä¸ªPWMå€¼åœç•™ï¼Œè®©ç”¨æˆ·è§‚å¯Ÿ
    unsigned long startTime = millis();
    while (millis() - startTime < dwellTime) {
      // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ ç´§æ€¥åœæ­¢æ£€æŸ¥
      if (Serial.available()) {
        char cmd = Serial.read();
        if (cmd == 's') {
          analogWrite(MOTOR_PWM_PIN, 0);
          Serial.println("æ‰«æè¢«ç”¨æˆ·ä¸­æ–­");
          return;
        }
      }
      delay(100);
    }
  }
  
  analogWrite(MOTOR_PWM_PIN, 0);
  Serial.println("è‡ªåŠ¨æ‰«æå®Œæˆ");
}
```

## ğŸ“Š é«˜çº§è‡ªåŠ¨æ£€æµ‹æ–¹æ³•

### 3. åŸºäºç”µæµæ£€æµ‹çš„è‡ªåŠ¨è¯†åˆ«
```cpp
/**
 * åŸºäºç”µæµå˜åŒ–è‡ªåŠ¨æ£€æµ‹æœ€å°å¯åŠ¨PWM
 * éœ€è¦è¿æ¥ç”µæµä¼ æ„Ÿå™¨åœ¨A0å¼•è„š
 */
#define CURRENT_SENSOR_PIN A0

int findMinPwmByCurrent() {
  Serial.println("åŸºäºç”µæµæ£€æµ‹è‡ªåŠ¨å¯»æ‰¾æœ€å°å¯åŠ¨PWM...");
  
  const int samples = 10;
  int minStartPwm = -1;
  float currentThreshold = 0.1; // ç”µæµé˜ˆå€¼ï¼Œéœ€è¦æ ¹æ®å®é™…æƒ…å†µè°ƒæ•´
  
  // å…ˆæµ‹é‡é™æ­¢ç”µæµ
  float idleCurrent = 0;
  for (int i = 0; i < samples; i++) {
    idleCurrent += analogRead(CURRENT_SENSOR_PIN);
    delay(10);
  }
  idleCurrent = idleCurrent / samples;
  
  Serial.printf("ç”µæœºé™æ­¢ç”µæµ: %.2f\n", idleCurrent);
  
  // æ‰«æPWMå€¼
  for (int pwm = 0; pwm <= 200; pwm += 2) {
    analogWrite(MOTOR_PWM_PIN, pwm);
    digitalWrite(MOTOR_DIR_PIN, HIGH);
    delay(500); // ç­‰å¾…ç¨³å®š
    
    // æµ‹é‡å½“å‰ç”µæµ
    float current = 0;
    for (int i = 0; i < samples; i++) {
      current += analogRead(CURRENT_SENSOR_PIN);
      delay(10);
    }
    current = current / samples;
    
    float currentChange = abs(current - idleCurrent);
    
    Serial.printf("PWM: %3d, ç”µæµ: %.2f, å˜åŒ–: %.2f\n", 
                  pwm, current, currentChange);
    
    // å¦‚æœç”µæµæ˜¾è‘—å¢åŠ ï¼Œè¯´æ˜ç”µæœºå¼€å§‹è½¬åŠ¨
    if (currentChange > currentThreshold && minStartPwm == -1) {
      minStartPwm = pwm;
      Serial.printf("ğŸš€ æ£€æµ‹åˆ°ç”µæœºå¯åŠ¨! PWM: %d\n", minStartPwm);
    }
    
    delay(200);
  }
  
  analogWrite(MOTOR_PWM_PIN, 0);
  
  if (minStartPwm != -1) {
    Serial.printf("âœ… è‡ªåŠ¨æ£€æµ‹æœ€å°å¯åŠ¨PWM: %d\n", minStartPwm);
    return minStartPwm;
  } else {
    Serial.println("âŒ æœªæ£€æµ‹åˆ°ç”µæœºå¯åŠ¨ï¼Œè¯·æ£€æŸ¥è¿æ¥");
    return -1;
  }
}
```
ç”µæµæµ‹é‡ï¼ˆåŸºäºACS712ï¼‰å®ä¾‹

``` cpp
// ACS712ç”µæµä¼ æ„Ÿå™¨ç¤ºä¾‹
const int currentSensorPin = A0;
int sensorValue = 0;
int offsetValue = 512;  // é›¶ç‚¹åç§»ï¼ˆæ— ç”µæµæ—¶è¾“å‡ºï¼Œé€šå¸¸ä¸ºVcc/2ï¼‰
float sensitivity = 0.185; // çµæ•åº¦ (mV/A) - æ ¹æ®å‹å·è°ƒæ•´
// 5Aç‰ˆæœ¬: 0.185V/A, 20Aç‰ˆæœ¬: 0.100V/A, 30Aç‰ˆæœ¬: 0.066V/A

void setup() {
  Serial.begin(9600);
  Serial.println("ACS712ç”µæµä¼ æ„Ÿå™¨æµ‹è¯•");
  
  // æ ¡å‡†é›¶ç‚¹ï¼ˆç¡®ä¿æ— ç”µæµé€šè¿‡æ—¶æµ‹é‡ï¼‰
  calibrateZeroPoint();
}

void loop() {
  float current = getCurrent();
  
  Serial.print("ç”µæµ: ");
  Serial.print(current, 2);
  Serial.println(" A");
  
  delay(500);
}

void calibrateZeroPoint() {
  Serial.println("æ ¡å‡†ä¸­...ç¡®ä¿æ— ç”µæµé€šè¿‡ä¼ æ„Ÿå™¨");
  delay(2000);
  
  long sum = 0;
  for (int i = 0; i < 100; i++) {
    sum += analogRead(currentSensorPin);
    delay(10);
  }
  offsetValue = sum / 100;
  
  Serial.print("é›¶ç‚¹æ ¡å‡†å€¼: ");
  Serial.println(offsetValue);
}

float getCurrent() {
  int analogValue = 0;
  
  // å¤šæ¬¡é‡‡æ ·å–å¹³å‡
  for (int i = 0; i < 10; i++) {
    analogValue += analogRead(currentSensorPin);
    delay(1);
  }
  analogValue = analogValue / 10;
  
  // è½¬æ¢ä¸ºç”µå‹ (Arduino ADCå‚è€ƒç”µå‹5V, 10ä½åˆ†è¾¨ç‡)
  float voltage = (analogValue - offsetValue) * 5.0 / 1024.0;
  
  // è½¬æ¢ä¸ºç”µæµ
  float current = voltage / sensitivity;
  
  return current;
}
```

### 4. æ™ºèƒ½äºŒåˆ†æœç´¢æ³•
```cpp
/**
 * ä½¿ç”¨äºŒåˆ†æ³•å¿«é€Ÿå®šä½æœ€å°å¯åŠ¨PWM
 * æ›´é«˜æ•ˆçš„æ–¹æ³•ï¼Œé€‚åˆç²¾ç¡®ç¡®å®š
 */
int binarySearchMinPwm(int low, int high) {
  Serial.println("ä½¿ç”¨äºŒåˆ†æ³•æœç´¢æœ€å°å¯åŠ¨PWM...");
  Serial.println("è¯·è§‚å¯Ÿç”µæœºå¹¶åœ¨æ¯æ¬¡æµ‹è¯•åè¾“å…¥åé¦ˆ");
  
  while (low <= high) {
    int mid = (low + high) / 2;
    
    Serial.printf("æµ‹è¯• PWM: %d - ç”µæœºæ˜¯å¦è½¬åŠ¨? (y/n): ", mid);
    analogWrite(MOTOR_PWM_PIN, mid);
    digitalWrite(MOTOR_DIR_PIN, HIGH);
    
    // ç­‰å¾…ç”¨æˆ·è¾“å…¥
    while (!Serial.available()) {
      delay(100);
    }
    
    char response = Serial.read();
    analogWrite(MOTOR_PWM_PIN, 0); // åœæ­¢ç”µæœºç­‰å¾…åé¦ˆ
    
    if (response == 'y' || response == 'Y') {
      // ç”µæœºè½¬åŠ¨ï¼Œå°è¯•æ›´å°çš„å€¼
      high = mid - 1;
      Serial.println(" âœ“ è½¬åŠ¨ -> å°è¯•æ›´å°å€¼");
    } else {
      // ç”µæœºä¸è½¬åŠ¨ï¼Œéœ€è¦æ›´å¤§çš„å€¼
      low = mid + 1;
      Serial.println(" âœ— ä¸è½¬åŠ¨ -> å°è¯•æ›´å¤§å€¼");
    }
    
    delay(500);
  }
  
  int minPwm = low;
  Serial.printf("âœ… æœ€å°å¯åŠ¨PWMç¡®å®šä¸º: %d\n", minPwm);
  return minPwm;
}
```

## ğŸ¯ å®Œæ•´çš„å¤šæ–¹æ³•æ ¡å‡†ç¨‹åº

```cpp
#include <Arduino.h>

#define MOTOR_PWM_PIN D1
#define MOTOR_DIR_PIN D2
#define CURRENT_SENSOR_PIN A0

int minStartPwm = 80; // é»˜è®¤å€¼ï¼Œå°†é€šè¿‡æ ¡å‡†æ›´æ–°

void setup() {
  Serial.begin(115200);
  pinMode(MOTOR_PWM_PIN, OUTPUT);
  pinMode(MOTOR_DIR_PIN, OUTPUT);
  pinMode(CURRENT_SENSOR_PIN, INPUT);
  
  analogWriteRange(1023);
  analogWriteFreq(1000);
  
  Serial.println();
  Serial.println("=== ESP8266 ç”µæœºæœ€å°å¯åŠ¨PWMæ ¡å‡†ç³»ç»Ÿ ===");
  Serial.println("é€‰æ‹©æ ¡å‡†æ–¹æ³•:");
  Serial.println("1 - æ‰‹åŠ¨äº¤äº’æ ¡å‡†");
  Serial.println("2 - è‡ªåŠ¨æ­¥è¿›æ‰«æ");
  Serial.println("3 - ç”µæµæ£€æµ‹è‡ªåŠ¨æ ¡å‡†");
  Serial.println("4 - äºŒåˆ†æ³•å¿«é€Ÿå®šä½");
  Serial.println("c - ä½¿ç”¨å½“å‰å­˜å‚¨çš„æœ€å°PWMå€¼");
  Serial.printf("å½“å‰æœ€å°PWM: %d\n", minStartPwm);
}

void loop() {
  if (Serial.available()) {
    char method = Serial.read();
    
    switch (method) {
      case '1':
        startManualCalibration();
        break;
      case '2':
        autoScanMinPwm();
        break;
      case '3':
        minStartPwm = findMinPwmByCurrent();
        break;
      case '4':
        minStartPwm = binarySearchMinPwm(0, 200);
        break;
      case 'c':
        Serial.printf("ä½¿ç”¨å½“å‰æœ€å°PWM: %d\n", minStartPwm);
        testCurrentMinPwm();
        break;
    }
    
    if (method >= '1' && method <= '4') {
      Serial.println("æ ¡å‡†å®Œæˆï¼");
      Serial.printf("æœ€ç»ˆç¡®å®šçš„æœ€å°å¯åŠ¨PWM: %d\n", minStartPwm);
      Serial.println("é€‰æ‹©å…¶ä»–æ–¹æ³•æˆ–é‡æ–°æµ‹è¯•");
    }
  }
}

void startManualCalibration() {
  Serial.println("æ‰‹åŠ¨æ ¡å‡†æ¨¡å¼ - ä½¿ç”¨ '+' å’Œ '-' è°ƒæ•´PWM");
  Serial.println("æŒ‰ 'y' ç¡®è®¤æ‰¾åˆ°æœ€å°å€¼ï¼ŒæŒ‰ '0' åœæ­¢");
  
  int pwm = 0;
  bool calibrating = true;
  
  while (calibrating) {
    if (Serial.available()) {
      char cmd = Serial.read();
      switch (cmd) {
        case '+': pwm = min(pwm + 5, 1023); break;
        case '-': pwm = max(pwm - 5, 0); break;
        case 'y': 
          minStartPwm = pwm;
          calibrating = false;
          break;
        case '0': 
          pwm = 0;
          calibrating = false;
          break;
      }
      
      analogWrite(MOTOR_PWM_PIN, pwm);
      digitalWrite(MOTOR_DIR_PIN, HIGH);
      Serial.printf("å½“å‰PWM: %d\n", pwm);
    }
    delay(100);
  }
  analogWrite(MOTOR_PWM_PIN, 0);
}

void testCurrentMinPwm() {
  Serial.printf("æµ‹è¯•å½“å‰æœ€å°PWMå€¼: %d\n", minStartPwm);
  
  for (int i = 0; i < 3; i++) {
    Serial.printf("æµ‹è¯• %d/3 - PWM: %d\n", i + 1, minStartPwm);
    analogWrite(MOTOR_PWM_PIN, minStartPwm);
    digitalWrite(MOTOR_DIR_PIN, HIGH);
    delay(2000);
    analogWrite(MOTOR_PWM_PIN, 0);
    delay(1000);
  }
  
  Serial.println("æµ‹è¯•å®Œæˆï¼Œç”µæœºæ˜¯å¦ç¨³å®šå¯åŠ¨?");
}
```

## ğŸ’¡ ä¸“ä¸šæ ¡å‡†æŠ€å·§ä¸å»ºè®®

### æ ¡å‡†ç¯å¢ƒè®¾ç½®
```cpp
/**
 * åˆ›å»ºç†æƒ³çš„æ ¡å‡†ç¯å¢ƒ
 */
void setupCalibrationEnvironment() {
  Serial.println("è®¾ç½®æ ¡å‡†ç¯å¢ƒ...");
  
  // 1. è®¾ç½®è¾ƒä½çš„PWMé¢‘ç‡ä»¥æé«˜ä½é€Ÿç¨³å®šæ€§
  analogWriteFreq(500);
  
  // 2. ç¡®ä¿ç”µæœºå¤„äºå…¸å‹è´Ÿè½½çŠ¶æ€
  Serial.println("è¯·ç¡®ä¿:");
  Serial.println("- ç”µæœºè¿æ¥å®é™…å·¥ä½œè´Ÿè½½");
  Serial.println("- ç”µæºç”µå‹ç¨³å®š");
  Serial.println("- ç¯å¢ƒæ¸©åº¦æ­£å¸¸");
  Serial.println("- æœºæ¢°ä¼ åŠ¨ç³»ç»Ÿæ— å¡æ¶©");
  
  delay(2000);
  
  // 3. é¢„çƒ­ç”µæœºï¼ˆå¯é€‰ï¼‰
  Serial.println("è¿›è¡Œç”µæœºé¢„çƒ­...");
  for (int i = 0; i < 3; i++) {
    analogWrite(MOTOR_PWM_PIN, 150);
    delay(1000);
    analogWrite(MOTOR_PWM_PIN, 0);
    delay(500);
  }
}
```

### å¤šé‡éªŒè¯æ–¹æ³•
```cpp
/**
 * å¤šé‡éªŒè¯ç¡®å®šçš„æœ€å°PWMå€¼
 */
bool validateMinPwm(int candidatePwm) {
  Serial.printf("éªŒè¯å€™é€‰PWMå€¼: %d\n", candidatePwm);
  
  int successCount = 0;
  const int totalTests = 5;
  
  for (int i = 0; i < totalTests; i++) {
    Serial.printf("éªŒè¯æµ‹è¯• %d/%d: ", i + 1, totalTests);
    
    analogWrite(MOTOR_PWM_PIN, candidatePwm);
    digitalWrite(MOTOR_DIR_PIN, HIGH);
    delay(2000);
    
    // è¿™é‡Œå¯ä»¥æ·»åŠ å®é™…çš„é€Ÿåº¦æ£€æµ‹æˆ–ç”µæµæ£€æµ‹
    // æš‚æ—¶ä½¿ç”¨ç”¨æˆ·åé¦ˆ
    Serial.println("ç”µæœºæ˜¯å¦ç¨³å®šè½¬åŠ¨? (y/n)");
    
    while (!Serial.available()) {
      delay(100);
    }
    
    char response = Serial.read();
    analogWrite(MOTOR_PWM_PIN, 0);
    
    if (response == 'y' || response == 'Y') {
      successCount++;
      Serial.println(" âœ“ é€šè¿‡");
    } else {
      Serial.println(" âœ— å¤±è´¥");
    }
    
    delay(1000);
  }
  
  float successRate = (float)successCount / totalTests * 100;
  Serial.printf("éªŒè¯æˆåŠŸç‡: %.1f%%\n", successRate);
  
  return successRate >= 80.0; // 80%æˆåŠŸç‡è®¤ä¸ºæœ‰æ•ˆ
}
```

## ğŸ“‹ æ ¡å‡†ç»“æœè®°å½•ä¸åˆ†æ

### æ•°æ®è®°å½•ç»“æ„
```cpp
struct MotorCalibrationData {
  int minStartPwm;
  int voltage;
  float temperature;
  String loadCondition;
  String timestamp;
  float successRate;
};

void saveCalibrationData(int minPwm) {
  MotorCalibrationData data;
  data.minStartPwm = minPwm;
  data.timestamp = String(millis());
  data.successRate = 100.0; // å®é™…åº”è¯¥è®¡ç®—
  
  Serial.println("=== æ ¡å‡†æ•°æ®è®°å½• ===");
  Serial.printf("æœ€å°å¯åŠ¨PWM: %d\n", data.minStartPwm);
  Serial.printf("æ ¡å‡†æ—¶é—´: %s\n", data.timestamp.c_str());
  Serial.printf("æˆåŠŸç‡: %.1f%%\n", data.successRate);
  Serial.println("====================");
}
```

## ğŸš€ ä½¿ç”¨å»ºè®®

1. **é€‰æ‹©åˆé€‚çš„æ ¡å‡†æ–¹æ³•**ï¼š
   - åˆæ¬¡æ ¡å‡†ï¼šä½¿ç”¨æ‰‹åŠ¨äº¤äº’æ ¡å‡†ï¼ˆæ–¹æ³•1ï¼‰
   - å¿«é€Ÿæ ¡å‡†ï¼šä½¿ç”¨äºŒåˆ†æ³•ï¼ˆæ–¹æ³•4ï¼‰
   - ç²¾ç¡®æ ¡å‡†ï¼šä½¿ç”¨ç”µæµæ£€æµ‹ï¼ˆæ–¹æ³•3ï¼‰

2. **è€ƒè™‘å½±å“å› ç´ **ï¼š
   - ç”µæºç”µå‹æ³¢åŠ¨
   - ç¯å¢ƒæ¸©åº¦å˜åŒ–
   - æœºæ¢°è´Ÿè½½å˜åŒ–
   - ç”µæœºç£¨æŸç¨‹åº¦

3. **å®šæœŸé‡æ–°æ ¡å‡†**ï¼š
   - å»ºè®®åœ¨é‡è¦åº”ç”¨å‰è¿›è¡Œæ ¡å‡†
   - ç”µæœºæˆ–è´Ÿè½½æ›´æ¢åé‡æ–°æ ¡å‡†
   - ç¯å¢ƒæ¡ä»¶æ˜¾è‘—å˜åŒ–æ—¶é‡æ–°æ ¡å‡†

é€šè¿‡è¿™å¥—å®Œæ•´çš„æ ¡å‡†ç³»ç»Ÿï¼Œä½ å¯ä»¥å‡†ç¡®ç¡®å®šä»»ä½•ç”µæœºåœ¨ESP8266æ§åˆ¶ä¸‹çš„æœ€å°å¯åŠ¨PWMå€¼ï¼Œä¸ºåç»­çš„ç²¾ç¡®é€Ÿåº¦æ§åˆ¶å¥ å®šåŸºç¡€ã€‚